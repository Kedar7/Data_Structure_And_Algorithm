WEBVTT

00:00.180 --> 00:00.630
All right.

00:00.630 --> 00:01.590
Welcome back.

00:01.590 --> 00:05.840
In this video I just want to do a quick walkthrough of the curriculum talks about what to expect.

00:05.880 --> 00:11.310
This course is a little different than others including my other courses in that it's not exactly linear.

00:11.310 --> 00:15.720
You don't have to go through every section in order at the beginning of every single section.

00:15.710 --> 00:22.130
There is a text lecture an article called prerequisites and that explains at a minimum the sections

00:22.140 --> 00:25.450
you need to have finished before you start the new section.

00:25.680 --> 00:30.210
And so let's just begin the very first section or technically the second one but the first technical

00:30.210 --> 00:32.640
section is called Big O notation.

00:32.730 --> 00:33.680
Really important stuff.

00:33.690 --> 00:38.490
We come back to every single section from basically there until the end of the course.

00:38.490 --> 00:42.760
It's a way of describing or talking about the performance the efficiency of code.

00:43.110 --> 00:46.570
So we use that all the time so definitely don't skip that.

00:46.740 --> 00:51.900
Then we move on to a really quick section called analyzing performance of arrays and objects.

00:51.930 --> 00:52.750
Nice and short.

00:52.890 --> 00:58.120
We take what we just learned about Big O notation and apply it to some built in data structures.

00:58.140 --> 00:59.470
We work with all the time.

00:59.520 --> 01:01.110
So that's really quick.

01:01.130 --> 01:06.860
Next we shift over to talking about interviews and algorithms challenges.

01:06.900 --> 01:10.980
Basically what do you do when you're confronted with a tough problem and you don't know how to solve

01:10.980 --> 01:11.390
it.

01:11.430 --> 01:15.870
Whether that's in an interview and you're on a whiteboard and you're panicking or it's at home you're

01:15.870 --> 01:18.450
working from side project or at work.

01:18.570 --> 01:20.820
How do you approach a difficult problem.

01:20.970 --> 01:24.360
And then the second sort of what will goes in tandem with that.

01:24.360 --> 01:27.870
These are two sections problem solving approach problem solving patterns.

01:27.900 --> 01:32.730
When we're talk about patterns we actually get into specific sort of archetypes here code they have

01:32.730 --> 01:37.620
different names things like divide and conquer sliding window frequency counter patterns.

01:37.650 --> 01:39.260
These are all different patterns we describe.

01:39.260 --> 01:40.670
There's a lot of challenges.

01:40.740 --> 01:45.870
This first section that comes before is more about sort of setting up a framework for you to think and

01:45.870 --> 01:48.910
approach a problem this is about concrete patterns.

01:49.020 --> 01:50.660
Then we move on to recursion.

01:50.670 --> 01:52.520
So recursion a really important topic.

01:52.650 --> 01:55.210
Definitely don't skip this if you're not familiar with recursion.

01:55.220 --> 01:58.020
It comes up later on in many of our algorithms.

01:58.020 --> 02:04.050
There's also to challenge sections sort of intermediate recursion problems and then tougher recursion

02:04.050 --> 02:08.410
problems that follow this section then we move on to searching algorithms.

02:08.430 --> 02:12.720
Fun one to talked about things like binary search here we've heard about that.

02:12.720 --> 02:14.880
Then we moved to sorting out algorithms.

02:14.880 --> 02:18.230
So I think we have six sorting algorithms at least.

02:18.450 --> 02:23.310
And these are kind of fun if you've never worked with sorting out for them so you've never heard about

02:23.310 --> 02:23.910
them.

02:23.970 --> 02:25.230
They have some odd names.

02:25.260 --> 02:29.570
We start with bubble sort which is often considered the easiest or one of the easiest.

02:29.580 --> 02:31.220
Move to selection sort.

02:31.320 --> 02:38.070
And then insertion sort and those three form a little group sort of the intermediate or elementary sorting

02:38.070 --> 02:43.440
algorithms then we move on to everyone's favorite and merge sort.

02:43.440 --> 02:44.140
I like merge sort.

02:44.160 --> 02:45.240
A lot of people don't.

02:45.270 --> 02:46.470
Then we get to quicksort.

02:46.560 --> 02:48.240
So these all involve recursion.

02:48.240 --> 02:49.980
They involve Big O notation.

02:49.980 --> 02:54.840
So it's very important that you pay attention to the prerequisite little text lectures at the beginning

02:54.840 --> 02:57.710
of every session to explain what you need.

02:57.960 --> 03:04.800
And then we finish up with radix sort a pretty rare sort and very fast in a special situation and not

03:04.800 --> 03:06.340
very often taught.

03:06.420 --> 03:08.930
Not in my experience I've never really seen it taught.

03:08.970 --> 03:09.710
It's a fun one though.

03:09.720 --> 03:11.010
I actually really liked it.

03:11.460 --> 03:16.350
So from there we get to sort of the second section of the course up until this point it's been about

03:17.160 --> 03:22.470
sort of steppingstones recursion Big-O notation problem solving approaches lots of algorithms searching

03:22.470 --> 03:23.700
sorting algorithms.

03:23.700 --> 03:25.970
Then we transition to data structures.

03:25.980 --> 03:31.880
So from this slide until the end of the Course there's a ton of different data structures we talk about.

03:32.040 --> 03:37.640
And this intro section compares them all it tries to answer the question what's the best data structure.

03:37.650 --> 03:39.800
And the answer is that there isn't one.

03:39.960 --> 03:42.810
But we talk about where they excel on certain structures.

03:42.810 --> 03:48.840
So we also talk about East 2015 class syntax if you're not familiar with how you can approximate an

03:48.840 --> 03:51.230
object current class using javascript.

03:51.240 --> 03:53.160
We talk about that in this section.

03:53.350 --> 03:58.730
Then we're going to run through these quickly singly linked lists then recovered doubly linked lists.

03:58.770 --> 04:01.080
So if you've never heard of these data structures.

04:01.260 --> 04:02.200
Very understandable.

04:02.280 --> 04:04.270
But we spend a lot of time talking about them.

04:04.350 --> 04:08.930
Then we move on to two more stacks and Qs very commonly use structures.

04:09.030 --> 04:14.820
Then we go to binary search trees really trees in general and then we specifically hone in on binary

04:14.820 --> 04:15.970
search trees.

04:16.110 --> 04:18.530
Then we have a section devoted to tree traversal.

04:18.570 --> 04:24.020
So if you have if you've ever heard the term breath first search depth first search post order preorder

04:24.030 --> 04:26.000
in order depth first traversal.

04:26.010 --> 04:28.090
That's the kind of stuff we cover here.

04:28.230 --> 04:28.780
Important.

04:28.800 --> 04:30.830
Somewhat intimidating.

04:31.020 --> 04:34.760
And again recall's on things like Big-O notation and recursion.

04:34.770 --> 04:38.080
It builds on length lists so a lot of this is interconnected.

04:38.100 --> 04:43.630
But you could also jump here and just look at the prerequisites and figure out what you need to learn.

04:43.980 --> 04:50.370
So then we go to binary heaps which is very related to trees but a very special case we talk about building

04:50.490 --> 04:51.950
something called a priority queue.

04:51.960 --> 04:54.150
This is a fun section in my opinion.

04:54.150 --> 04:55.680
Then we go to hash tables.

04:55.680 --> 05:01.930
I also like the section hash tables we talked about very your data structure that what we're doing here

05:01.930 --> 05:07.250
is sort of understanding how javascript objects work how they're implemented behind the scenes.

05:07.330 --> 05:10.600
How would you implement a key value pair data structure.

05:10.900 --> 05:12.640
And we talked about hashing algorithms.

05:12.700 --> 05:14.230
I think it's a fun one.

05:14.290 --> 05:18.880
Then we go to Graf's something that a lot of people are intimidated by.

05:18.880 --> 05:27.190
We talk about how you would model GPS Global Positioning Ogaden my cat it can interrupt me like that.

05:27.190 --> 05:27.550
What is it.

05:27.550 --> 05:35.400
GVS mapping to figure out how to find basically how would you represent a map and traffic data and all

05:35.420 --> 05:40.950
these different variables so that you could create a GPS application or something like that.

05:40.990 --> 05:46.040
We also talk about storing social network data and one way relationship to a relationships.

05:46.360 --> 05:50.290
We explore a lot of stuff around Graf's networks routing.

05:50.380 --> 05:56.020
We talk about graph traversal which Well I won't get into too much same thing breadth first depth versus

05:56.020 --> 05:57.000
If we've heard of that.

05:57.190 --> 06:01.990
And then one of my favorite parts of the course and one of the more complicated things you talked about

06:02.020 --> 06:07.960
is called Dijkstra's algorithm and this has to do with finding the shortest path between two nodes on

06:07.960 --> 06:10.460
a graph to vertices if that means nothing to you.

06:10.480 --> 06:13.520
Well this course is still definitely for you.

06:13.540 --> 06:15.760
You're not expected to understand what that is.

06:15.760 --> 06:21.400
But if we go back to the idea of GPs say you want to get from point A to point B from New York to Los

06:21.400 --> 06:24.160
Angeles which is the fastest way to do that on the roads.

06:24.160 --> 06:30.670
If we have a complete map of all the roads and let's ignore traffic data just distances What's the best

06:30.670 --> 06:31.750
way to calculate that.

06:31.750 --> 06:33.430
I mean there's so many possibilities.

06:33.520 --> 06:38.220
So we learn an algorithm to do that and we do basically an approximation of the same thing.

06:38.350 --> 06:41.830
It's this very famous mathematician and computer scientist.

06:41.830 --> 06:47.290
DYKSTRA came up with it and that's what we talked about here and this is sort of a pinnacle of the course

06:47.290 --> 06:55.150
because we talk it relies on Big-O notation recursion it relies on heape Spiner heaps priority queues

06:55.210 --> 07:00.020
stacks a lot of things that we talked about earlier in the course come back in this last section.

07:00.160 --> 07:01.960
Oh Graf's I forgot to mention graphs.

07:01.960 --> 07:06.110
So that's where we finish up really just to revisit this.

07:06.190 --> 07:11.590
There's a division right here intro to data structures where everything else is focused on individual

07:11.590 --> 07:13.190
data structures from there on out.

07:13.300 --> 07:17.930
And before that there's some really important stuff sorting algorithms searching algorithms.

07:18.010 --> 07:21.160
But no matter what I recommend you start with Big-O notation.

07:21.220 --> 07:25.960
Don't skip the recursion sections and then from there till they get to you just pay attention to the

07:25.960 --> 07:27.490
prerequisite lectures.

07:27.490 --> 07:29.080
You absolutely can go in order.

07:29.080 --> 07:30.860
I mean it's designed in an order.

07:30.910 --> 07:35.920
It's not just arbitrary but if you don't want to sit through all of doubly linked lists you could skip

07:35.920 --> 07:40.410
it as long as he did singly linked lists anyway I'll see in the course.

07:40.420 --> 07:41.120
Goodbye.

07:41.230 --> 07:42.700
I don't know how to end this by.
