WEBVTT

00:00.180 --> 00:01.350
So insertion sort.

00:01.350 --> 00:07.230
As far as its time complexity it's pretty similar overall to the other two we've seen its worst case

00:07.300 --> 00:11.630
of and squared is quadratic because were it for the length that the array grows.

00:11.640 --> 00:15.530
We also have to basically make n squared number of comparisons.

00:16.020 --> 00:18.880
But if our data is almost all sorted.

00:19.080 --> 00:27.540
So if instead we were looking at something like I don't know what would work here let's say 1 2 3 4

00:27.990 --> 00:29.640
negative 1 for example.

00:29.850 --> 00:33.690
Well if we start we look at two we immediately find that it's greater.

00:33.690 --> 00:35.640
We don't have to do anything we stop the loop.

00:35.730 --> 00:36.660
Then we move to three.

00:36.690 --> 00:38.080
We find that it's greater than 2.

00:38.220 --> 00:39.500
We don't need to keep going.

00:39.780 --> 00:43.160
We look at four Where could we look at negative one.

00:43.170 --> 00:43.530
All right.

00:43.530 --> 00:46.050
Now we have to go through and put it at the beginning.

00:46.320 --> 00:52.760
But compare that to a totally random unsorted data where we have to continually play something and iterate.

00:52.950 --> 00:58.890
Then we're looking at a much worse time or actually what's the worst possible scenario something like

00:58.890 --> 01:00.710
this where you start.

01:00.780 --> 01:01.690
We get to three.

01:01.710 --> 01:03.970
We have to swap it to here and we get to two.

01:04.030 --> 01:08.260
We have to swap it to the beginning and we get to 1 and we have to swap to the beginning again.

01:08.310 --> 01:10.440
That's the worst case for insertion sort.

01:10.560 --> 01:13.300
But if your data is nearly sorted you're get.

01:13.350 --> 01:16.610
Now another interesting thing that insertion sort is good at.

01:16.980 --> 01:22.560
If you're data there's something called an online algorithm which is an algorithm that can work as data

01:22.560 --> 01:24.720
is coming in as it receives new data.

01:24.720 --> 01:27.390
It doesn't have to have the entire array at once.

01:27.390 --> 01:34.540
So for example let's say that we have some code where people are submitting numbers to us online live.

01:34.590 --> 01:36.570
We're getting them and we want to sort them in.

01:36.570 --> 01:37.390
Don't ask why.

01:37.440 --> 01:38.560
Let's say we wanted to.

01:38.720 --> 01:44.040
With insertion sort because the way that it works that we're keeping one side of the array sorted and

01:44.040 --> 01:48.700
we're inserting items one at a time it doesn't matter what the number is that comes in.

01:48.870 --> 01:50.680
We can place it where it needs to go.

01:50.700 --> 01:56.400
So this that's one strength if you do need if you're looking for a sorting algorithm that works in that

01:56.400 --> 02:01.470
way which probably isn't going to come up but it is worth knowing that because of how insertion sort

02:01.470 --> 02:07.050
works for because we keep one side of it sorted and we insert things in the appropriate place because

02:07.040 --> 02:11.370
of that it works well in a situation where data is coming in live or streaming.

02:11.370 --> 02:14.000
And you need to insert it at a moment's notice.

02:14.220 --> 02:14.610
OK.

02:14.640 --> 02:18.200
So those are the three elementary sorting out rhythms in the next video.

02:18.210 --> 02:21.890
We'll just wrap up talking about their time complexity and space complexity.

02:21.890 --> 02:24.410
And then also do a quick recap of what we learned.
